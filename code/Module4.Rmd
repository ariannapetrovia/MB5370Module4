---
title: "MB5370 Module 04. Workshop 1 - Introduction"
author: "Ben Cresswell"
output: html_document
date: "2024-03-22"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Install and load tidyverse packages
```{r}
## install.packages("tidyverse") # Delete this line once installed
library("tidyverse")
```


# Load the data (mpg is built into ggplot2)
```{r}
data(mpg)
```


# Quick data checks
```{r}
head(mpg)
glimpse(mpg)
summary(mpg)
```


# Create first plot
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```

The plot shows a negative relationship between engine size (displ) and fuel efficiency (hwy). In other words, cars with big engines use more fuel. What does this say about fuel efficiency and engine size?



# Understanding grammar of graphics
What happens if we just try to run ggplot on its own?
```{r}
ggplot() 
# Or with just the data specified?
ggplot(data = mpg)
```

We need to map some aesthetics!!

# When you’re creating a plot, you essentially need two attributes of a plot: a geom and aesthetics.
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```


# Change point colour by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, colour = class))
```

# Change point size by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
```
Note the warning!!!


# Change transparency (alpha) by class
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))
```
Another warning!!
Question: When would using alpha (or size be appropriate??)

# Change point shape by class:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))
```


# Make all points blue
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")
```


# Troubleshooting 






# Faceting

## facet_wrap
Split the plot out by car type (class)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_wrap(~ class, nrow = 2)
```


## facet_grid
A separate facet for each combination of drive-type (e.g. 4WD) * number of cylinders
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(drv ~ cyl)
```
Note that there are no occurrences of 5 cylinder 4WDs OR RWD vehicles!


## facet_grid by just row (or column)
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) + 
  facet_grid(cyl ~ .)
  #facet_grid(. ~ cyl) # Alternatively

```

# Exercise:
Read ?facet_wrap. What does nrow do? What does ncol do? What other options control the layout of the individual panels? 

```{r}
?facet_wrap
```
nrow is number of rows
ncol is number of columns
shrink shrinks the scales to fit the output
labeller- each input collum corresponds to one factor


# Lines
We already used points:
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))
```


However, ggplot2 can use a variety of geom objects to represent the data. Here, we might want to use bar plots, line charts, boxplots and so on. Well we can handle this issue in ggplot directly using a different geom to plot the same data. Here, instead of plotting points, we will use a smooth line. 

# To display the same data as a smooth line fit through the points use geom_smooth().
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy))
```
### Question: whey don't we use geom_line() here? What would that look like? ###


So let’s recap. A geom is an object that your plot uses to represent the data. To change the geom type in your plot, simply change the geom function that you add to your plot template. Sometimes you may want to try a few things out, in which case you could use comments to help you remember what worked and what didn’t. 

## Using comments (#)
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy)) # try smooth line
```

Question: how does R work out where to plot the line??? Can use the chunk output to inform us. Can also use the help menu.

# Changing linetype
```{r}
ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy, linetype = drv)) # Can also use "lty = " for the same result
```


# Grouping
```{r}
ggplot(data = mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))
```
 
# Change line colour based on drv value
```{r}
ggplot(data = mpg) +
  geom_smooth(
    mapping = aes(x = displ, y = hwy, color = drv),
    show.legend = FALSE,
  )
```

# Multiple geoms
We already did this one way
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  geom_smooth(mapping = aes(x = displ, y = hwy))
```

A better way...
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()
```


# Can still manipulate each geom/layer separately:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth()
```

Now we have different colours to indicate the raw data (geom_point) and one colour for the overall relationship (geom_smooth). Neat!


```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) + 
  geom_smooth(data = filter(mpg, class == "subcompact"), se = FALSE)
```
Question: what does the "se = FALSE" do?


# Exercise:
1.  What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?
Line chart → geom_line()

Boxplot → geom_boxplot()

Histogram → geom_histogram()

Area chart → geom_area()
2.  Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

```{r}


# Line chart
ggplot(economics, aes(x = date, y = unemploy)) +
  geom_line()

# Boxplot
ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot()

# Histogram
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(binwidth = 2)

# Area chart
ggplot(economics, aes(x = date, y = unemploy)) +
  geom_area()

```


3.  Will these two graphs look different? Why/why not?
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```
no because for both you're plotting points and a smooth line using the same data. 

# Transformations and stats

## Load data
```{r}
data("diamonds")
glimpse(diamonds)
```

# Bar plot
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut))
```

# Overriding defaults
Make some new data
```{r}
demo <- tribble(
  ~cut,         ~freq,
  "Fair",       1610,
  "Good",       4906,
  "Very Good",  12082,
  "Premium",    13791,
  "Ideal",      21551
)
demo
```


```{r}
ggplot(data = demo) +
  geom_bar(mapping = aes(x = cut, y = freq), stat = "identity")
```
Question: Why did we specify now specify a y axis?

# What if we want to know the proportion rather than the absolute frequency?
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))
```

Question: does anyone get the warning that's in the workbook?
Warning: `stat(prop)` was deprecated in ggplot2 3.4.0.
If so, can use # geom_bar(mapping = aes(x = cut, y = stage(after_stat = prop), group = 1))

# Plotting statistical details
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```


# Aesthetic adjustments adjustments
Another way to boost the way you can convey information with plots using ggplot2 is to use aesthetics like colour or fill to change aspects of bar colours. We already did this once, but there are multiple options available to you, including changing the fill our outline colours.

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```
Question: Does anyone notice anything different in the colour scheme of this plot?
(Hint: It's in the viridis colour palette (colour blind friendly), but why is it different from the colour palette we used earlier?)
Check out the difference:
```{r}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = class)) 

ggplot(data = diamonds, mapping = aes(x = color, y = depth)) + 
  geom_point(mapping = aes(color = cut)) 
```


# Filling by a variable
Now try using these aesthetics to colour by another variable like clarity. Notice how the stacking is done automatically. This is done behind the scenes with a position argument.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```


# To alter transparency (alpha)
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
```


# To color the bar outlines with no fill color
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```


# Position adjustments
position = "fill" works like stacking, but makes each set of stacked bars the same height.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```


# position = "dodge" 
Places overlapping objects directly beside one another.
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```

# Jittering
position = "jitter" adds a small amount of random noise to each point to avoid overplotting when points overlap. This is useful for scatterplots but not barplots.
```{r}
ggplot(data = mpg) + 
  #geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
  geom_point(mapping = aes(x = displ, y = hwy))
```

2.25 Plot deconstruction
```{r}
library(ggplot2)
library(dplyr)

# Data (cleaned and all in millions for consistency)
ads_data <- data.frame(
  category = c("Abusing the ad network", "Trademark", "Personalized ads", 
               "Financial services", "Legal requirements", "Misrepresentation", 
               "Gambling and games", "Adult content", "Healthcare and medicines", 
               "Copyright", "Inappropriate content", "Misinformation", 
               "Enabling dishonest behavior", "Alcohol", 
               "Dangerous products/services", "Counterfeit goods", "Sensitive events"),
  ads_million = c(1040, 548.2, 372, 273.4, 209.5, 206.5, 192.7, 94.6, 
                  80.5, 65.4, 39.6, 30, 19.8, 9.2, 8.1, 2.1, 1.6)
)

# Order categories by descending ads_million
ads_data <- ads_data %>%
  arrange(desc(ads_million))

# Plot
ggplot(ads_data, aes(x = reorder(category, ads_million), y = ads_million)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Number of Ads Blocked or Removed in 2023",
    x = NULL,
    y = "Ads blocked/removed (millions)"
  ) +
  theme_minimal(base_size = 12)
```
```{r}
library(ggplot2)
library(dplyr)

# Original data
ads_data <- data.frame(
  category = c("Abusing the ad network", "Trademark", "Personalized ads", 
               "Financial services", "Legal requirements", "Misrepresentation", 
               "Gambling and games", "Adult content", "Healthcare and medicines", 
               "Copyright", "Inappropriate content", "Misinformation", 
               "Enabling dishonest behavior", "Alcohol", 
               "Dangerous products/services", "Counterfeit goods", "Sensitive events"),
  ads_million = c(1040, 548.2, 372, 273.4, 209.5, 206.5, 192.7, 94.6, 
                  80.5, 65.4, 39.6, 30, 19.8, 9.2, 8.1, 2.1, 1.6)
)

# Group categories
ads_grouped <- ads_data %>%
  mutate(group = case_when(
    category %in% c("Misrepresentation", "Enabling dishonest behavior", 
                    "Misinformation", "Inappropriate content") ~ "Content/Dishonesty",
    category %in% c("Financial services", "Healthcare and medicines", 
                    "Gambling and games", "Alcohol", "Dangerous products/services", 
                    "Counterfeit goods") ~ "Products/Services",
    category %in% c("Trademark", "Copyright", "Legal requirements") ~ "Legal/IP",
    category %in% c("Adult content", "Sensitive events") ~ "Sensitive/Adult",
    category %in% c("Personalized ads") ~ "Personalized ads",
    category %in% c("Abusing the ad network") ~ "Ad network abuse",
    TRUE ~ "Other"
  )) %>%
  group_by(group) %>%
  summarise(total_ads = sum(ads_million)) %>%
  arrange(desc(total_ads))

# Okabe–Ito color palette (8 colors, color-blind safe)
okabe_ito <- c("#E69F00", "#56B4E9", "#009E73", 
               "#F0E442", "#0072B2", "#D55E00", "#CC79A7")

# Plot with color-blind friendly palette
ggplot(ads_grouped, aes(x = reorder(group, total_ads), y = total_ads, fill = group)) +
  geom_col() +
  scale_fill_manual(values = okabe_ito) +
  coord_flip() +
  labs(
    title = "Number of Ads Blocked or Removed in 2023 (Grouped Categories)",
    x = NULL,
    y = "Ads blocked/removed (millions)",
    fill = "Policy group"
  ) +
  theme_minimal(base_size = 12)

```
```{r}
library(ggplot2)
library(dplyr)
library(viridis)

# Original data (all in millions for consistency)
ads_data <- data.frame(
  category = c("Abusing the ad network", "Trademark", "Personalized ads", 
               "Financial services", "Legal requirements", "Misrepresentation", 
               "Gambling and games", "Adult content", "Healthcare and medicines", 
               "Copyright", "Inappropriate content", "Misinformation", 
               "Enabling dishonest behavior", "Alcohol", 
               "Dangerous products/services", "Counterfeit goods", "Sensitive events"),
  ads_million = c(1040, 548.2, 372, 273.4, 209.5, 206.5, 192.7, 94.6, 
                  80.5, 65.4, 39.6, 30, 19.8, 9.2, 8.1, 2.1, 1.6)
)

# Sort categories by value
ads_data <- ads_data %>%
  arrange(desc(ads_million))

# Plot with viridis gradient
ggplot(ads_data, aes(x = reorder(category, ads_million), y = ads_million, fill = ads_million)) +
  geom_col() +
  scale_fill_viridis(option = "plasma", direction = -1) +  # options: "viridis", "magma", "cividis", "plasma"
  coord_flip() +
  labs(
    title = "Number of Ads Blocked or Removed in 2023",
    x = NULL,
    y = "Ads blocked/removed (millions)",
    fill = "Ads (millions)"
  ) +
  theme_minimal(base_size = 12)

```


-----Workshop 2------
Using ggplot2 for communication
adding title and subtitle

```{r}

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = "Fuel efficiency generally decreases with engine size",
    subtitle = "Two seaters (sports cars) are an exception because of their light weight",
    caption = "Data from fueleconomy.gov"
  )


```

Labels
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = "Engine displacement (L)",
    y = "Highway fuel economy (mpg)",
    colour = "Car type"
  )


```

Annotations
```{r}
best_in_class <- mpg %>%
  group_by(class) %>%
  filter(row_number(desc(hwy)) == 1)

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  geom_text(aes(label = model), data = best_in_class)

```
Scales
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_colour_discrete()



```
Axis Ticks
```{r}
ggplot(mpg, aes(displ, hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))
```
Legends and colors
```{r}
base <- ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(colour = class))

base + theme(legend.position = "right")

```
changes where the the legend is placed

Replacing a scale
```{r}
ggplot(diamonds, aes(carat, price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv))

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv)) +
  scale_colour_brewer(palette = "Set1")

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_colour_brewer(palette = "Set1")


```

when you have predefined colours
```{r}
presidential %>%
  mutate(id = 33 + row_number()) %>%
  ggplot(aes(start, id, colour = party)) +
    geom_point() +
    geom_segment(aes(xend = end, yend = id)) +
    scale_colour_manual(values = c(Republican = "red", Democratic = "blue"))


```
Themes
```{r}

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_light()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_classic()

ggplot(mpg, aes(displ, hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_dark()


```
new geom
```{r}
install.packages('viridis')
install.packages('hexbin')
library(viridis)
library(hexbin)

df <- tibble( # note we're just making a fake dataset so we can plot it
  x = rnorm(10000),
  y = rnorm(10000)
)
ggplot(df, aes(x, y)) +
  geom_hex() + # a new geom!
  coord_fixed()

ggplot(df, aes(x, y)) +
  geom_hex() +
  viridis::scale_fill_viridis() +
  coord_fixed()


```
3.10 Assignment End-to-end data analysis in R

------------------------------
Workshop 3: Data wrangling in r
```{r}
library(tidyverse)

table1
#> # A tibble: 6 × 4
#>   country      year  cases population
#>   <chr>       <int>  <int>      <int>
#> 1 Afghanistan  1999    745   19987071
#> 2 Afghanistan  2000   2666   20595360
#> 3 Brazil       1999  37737  172006362
#> 4 Brazil       2000  80488  174504898
#> 5 China        1999 212258 1272915272
#> 6 China        2000 213766 1280428583
table2
#> # A tibble: 12 × 4
#>   country      year type           count
#>   <chr>       <int> <chr>          <int>
#> 1 Afghanistan  1999 cases            745
#> 2 Afghanistan  1999 population  19987071
#> 3 Afghanistan  2000 cases           2666
#> 4 Afghanistan  2000 population  20595360
#> 5 Brazil       1999 cases          37737
#> 6 Brazil       1999 population 172006362
#> # ... with 6 more rows
table3
#> # A tibble: 6 × 3
#>   country      year rate             
#> * <chr>       <int> <chr>            
#> 1 Afghanistan  1999 745/19987071     
#> 2 Afghanistan  2000 2666/20595360    
#> 3 Brazil       1999 37737/172006362  
#> 4 Brazil       2000 80488/174504898  
#> 5 China        1999 212258/1272915272
#> 6 China        2000 213766/1280428583



```
```{r}
# Compute rate per 10,000
table1 %>% 
  mutate(rate = cases / population * 10000)
#> # A tibble: 6 × 5
#>   country      year  cases population  rate
#>   <chr>       <int>  <int>      <int> <dbl>
#> 1 Afghanistan  1999    745   19987071 0.373
#> 2 Afghanistan  2000   2666   20595360 1.29 
#> 3 Brazil       1999  37737  172006362 2.19 
#> 4 Brazil       2000  80488  174504898 5.61 
#> 5 China        1999 212258 1272915272 1.67 
#> 6 China        2000 213766 1280428583 1.67

# Compute cases per year
table1 %>% 
  count(year, wt = cases)
#> # A tibble: 2 × 2
#>    year      n
#>   <int>  <int>
#> 1  1999 250740
#> 2  2000 296920

# Visualise changes over time
library(ggplot2)
ggplot(table1, aes(year, cases)) + 
  geom_line(aes(group = country), colour = "grey50") + 
  geom_point(aes(colour = country))

```
4.4.1 Exercise 
What each column and observaton represents:
table 1= a country- year combination. Columns: name of country, year of observation, number of TB cases, population of the country in that year.

table 2= a single measurement for a given country-year. Columns: name of the country, year of observation, type of measurement (cases or population), value of the measurement.

table 3= a country-year combination. Columns: name of the country, year of observation, rate of TB cases per population (as a string).

calculating the rate= (cases/population)*10000
table 2: requires reshaping from long to wide before calculating
steps: extract number of TB cases, extract the matching population, bring them together, calculate rate, store result
table 3: requires separating the rate column into cases and population before calculating

```{r}
billboard
#> # A tibble: 317 × 79
#>   artist       track               date.entered   wk1   wk2   wk3   wk4   wk5
#>   <chr>        <chr>               <date>       <dbl> <dbl> <dbl> <dbl> <dbl>
#> 1 2 Pac        Baby Don't Cry (Ke... 2000-02-26      87    82    72    77    87
#> 2 2Ge+her      The Hardest Part O... 2000-09-02      91    87    92    NA    NA
#> 3 3 Doors Down Kryptonite          2000-04-08      81    70    68    67    66
#> 4 3 Doors Down Loser               2000-10-21      76    76    72    69    67
#> 5 504 Boyz     Wobble Wobble       2000-04-15      57    34    25    17    17
#> 6 98^0         Give Me Just One N... 2000-08-19      51    39    34    26    26
#> # ℹ 311 more rows
#> # ℹ 71 more variables: wk6 <dbl>, wk7 <dbl>, wk8 <dbl>, wk9 <dbl>, ...


```
```{r}
billboard |> 
  pivot_longer(
    cols = starts_with("wk"), 
    names_to = "week", 
    values_to = "rank",
    values_drop_na = TRUE
  )
#> # A tibble: 5,307 × 5
#>   artist track                   date.entered week   rank
#>   <chr>  <chr>                   <date>       <chr> <dbl>
#> 1 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk1      87
#> 2 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk2      82
#> 3 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk3      72
#> 4 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk4      77
#> 5 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk5      87
#> 6 2 Pac  Baby Don't Cry (Keep... 2000-02-26   wk6      94
#> # ℹ 5,301 more rows


```
```{r}
df <- tribble(
  ~id,  ~bp1, ~bp2,
   "A",  100,  120,
   "B",  140,  115,
   "C",  120,  125
)


```

```{r}
df |> 
  pivot_longer(
    cols = bp1:bp2,
    names_to = "measurement",
    values_to = "value"
  )
#> # A tibble: 6 × 3
#>   id    measurement value
#>   <chr> <chr>       <dbl>
#> 1 A     bp1           100
#> 2 A     bp2           120
#> 3 B     bp1           140
#> 4 B     bp2           115
#> 5 C     bp1           120
#> 6 C     bp2           125


```
```{r}
cms_patient_experience |> 
  pivot_wider(
    id_cols = starts_with("org"),
    names_from = measure_cd,
    values_from = prf_rate
  )
```
Above code used data from Centers of Medicare and Medicaid

Pivotting wider
```{r}
df <- tribble(
  ~id, ~measurement, ~value,
  "A",        "bp1",    100,
  "B",        "bp1",    140,
  "B",        "bp2",    115, 
  "A",        "bp2",    120,
  "A",        "bp3",    105
)

df |> 
  pivot_wider(
    names_from = measurement,
    values_from = value
  )

```
```{r}
df |> 
  distinct(measurement) |> 
  pull() 
```
4.5.5 Exercies
1. Pivot longer and pivot wider aren't perfectly symmetrical because when the values are turned into column names, they get stored as strings and R doesnt automatically know you want them back to numbers.
2. Name ptypes lets you control the type of the new colums created from column names. 
```{r}
table4a %>% 
  pivot_longer(c(1999, 2000), names_to = "year", values_to = "cases")

```
This code gauls because it's treating 1999 and 2000 as column positions, not names. Fix: 
```{r}
table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")

```
4. Preg data
```{r}
preg <- tribble(
  ~pregnant, ~male, ~female,
  "yes",     NA,    10,
  "no",      20,    12
)

```
variables: whether someone is pregnant, male of female, number of people. to make it longer:
```{r}
preg %>%
  pivot_longer(cols = c(male, female), 
               names_to = "sex", 
               values_to = "count")

```
4.5.6
```{r}
table3

```
```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"))
```
```{r}
table3 %>% 
  separate(rate, into = c("cases", "population"), sep = "/")


```
```{r}
table3 %>% 
  separate(year, into = c("century", "year"), sep = 2)
```
```{r}
table5 %>% 
  unite(new, century, year, sep = "")
```
4.6
```{r}
treatment <- tribble(
  ~person,           ~treatment, ~response,
  "Derrick Whitmore", 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  "Katherine Burke",  1,         4
)

treatment |>
  fill(everything())
```
```{r}
x <- c(1, 4, 5, 7, NA)
coalesce(x, 0)

```
```{r}
x <- c(1, 4, 5, 7, -99)
na_if(x, -99)
```
NaN
```{r}
x <- c(NA, NaN)
x * 10
#> [1]  NA NaN
x == 1
#> [1] NA NA
is.na(x)
#> [1] TRUE TRUE

stocks <- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)

stocks |>
  pivot_wider(
    names_from = qtr, 
    values_from = price
  )

```
```{r}
? read_csv
students <- read_csv("https://pos.it/r4ds-students-csv")


```
```{r}
students
```
```{r}
students |> 
  rename(
    student_id = `Student ID`,
    full_name = `Full Name`
  )

```
4.7.3 Exercise
1. Problem: Header has 2 columns but the data rows have 3 values 
What happens: readr reads the extra values into a column named ...3, you'll get a tibble with 3 columnts.
2. Problem: Header has 3 columns, but the first data row has only 2 values, and the second has 4 values.
What happens:
Missing values get filled with NA.
Extra values get stored in a new column ...4.
You’ll see a tibble with 4 columns: a, b, c, and ...4.
3. Problem: Unclosed quote — "1 starts a string but is never terminated.
What happens: Parsing fails with an error like "EOF within quoted string". The code doesn’t return a tibble.
4. Problem: Second data row has text "a","b" where numbers are expected.
What happens: read_csv() will still parse it, but it will warn about a parsing issue. The column type may be promoted to character, or the mismatched row will get NA if forced to numeric.
5. Problem: Uses semicolons (;) instead of commas (,).
What happens: Since read_csv() expects commas, the whole line is treated as one column. You get a tibble with a single column named "a;b" and one row "1;3".
Fix: use read_csv2() (which defaults to ; separator), or specify read_csv("a;b\n1;3", delim = ";").

4.8 Relational Data
```{r}
library(tidyverse)
install.packages("nycflights13")
library(nycflights13)

```
```{r}
airlines
```
```{r}
airports
```
```{r}
planes
```
```{r}
weather
```
```{r}
planes %>% 
  count(tailnum) %>% 
  filter(n > 1)
#> # A tibble: 0 × 2
#> # ... with 2 variables: tailnum <chr>, n <int>

weather %>% 
  count(year, month, day, hour, origin) %>% 
  filter(n > 1)
#> # A tibble: 3 × 6
#>    year month   day  hour origin     n
#>   <int> <int> <int> <int> <chr>  <int>
#> 1  2013    11     3     1 EWR        2
#> 2  2013    11     3     1 JFK        2
#> 3  2013    11     3     1 LGA        2
flights %>% 
  count(year, month, day, flight) %>% 
  filter(n > 1)
#> # A tibble: 29,768 × 5
#>    year month   day flight     n
#>   <int> <int> <int>  <int> <int>
#> 1  2013     1     1      1     2
#> 2  2013     1     1      3     2
#> 3  2013     1     1      4     2
#> 4  2013     1     1     11     3
#> 5  2013     1     1     15     2
#> 6  2013     1     1     21     2
#> # ... with 29,762 more rows

flights %>% 
  count(year, month, day, tailnum) %>% 
  filter(n > 1)
#> # A tibble: 64,928 × 5

```
```{r}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)

flights2 %>%
  select(-origin, -dest) %>% 
  left_join(airlines, by = "carrier")

flights2 %>%
  select(-origin, -dest) %>% 
  mutate(name = airlines$name[match(carrier, airlines$carrier)])

```
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)

x %>% 
  inner_join(y, by = "key")


```
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     1, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2"
)
left_join(x, y, by = "key")

```
```{r}
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     2, "x3",
     3, "x4"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     2, "y3",
     3, "y4"
)
left_join(x, y, by = "key")

```
```{r}
flights2 %>% 
  left_join(weather)
```


